// Code generated by goa v3.13.0, DO NOT EDIT.
//
// servers HTTP server types
//
// Command:
// $ goa gen github.com/dipankardas011/crop-yield-monitor/src/images/design

package server

import (
	"unicode/utf8"

	servers "github.com/dipankardas011/crop-yield-monitor/src/images/gen/servers"
	goa "goa.design/goa/v3/pkg"
)

// UploadRequestBody is the type of the "servers" service "upload" endpoint
// HTTP request body.
type UploadRequestBody struct {
	// unique userid
	UUID *string `form:"uuid,omitempty" json:"uuid,omitempty" xml:"uuid,omitempty"`
	// image in byte array
	Image []byte `form:"image,omitempty" json:"image,omitempty" xml:"image,omitempty"`
}

// FetchRequestBody is the type of the "servers" service "fetch" endpoint HTTP
// request body.
type FetchRequestBody struct {
	// unique userid
	UUID *string `form:"uuid,omitempty" json:"uuid,omitempty" xml:"uuid,omitempty"`
}

// UploadResponseBody is the type of the "servers" service "upload" endpoint
// HTTP response body.
type UploadResponseBody struct {
	// operation successful?
	OK bool `form:"ok" json:"ok" xml:"ok"`
	// error reason
	Error string `form:"error" json:"error" xml:"error"`
	// image in []byte
	Image []byte `form:"image,omitempty" json:"image,omitempty" xml:"image,omitempty"`
}

// FetchResponseBody is the type of the "servers" service "fetch" endpoint HTTP
// response body.
type FetchResponseBody struct {
	// operation successful?
	OK bool `form:"ok" json:"ok" xml:"ok"`
	// error reason
	Error string `form:"error" json:"error" xml:"error"`
	// image in []byte
	Image []byte `form:"image,omitempty" json:"image,omitempty" xml:"image,omitempty"`
}

// GetHealthResponseBody is the type of the "servers" service "get health"
// endpoint HTTP response body.
type GetHealthResponseBody struct {
	// message
	Msg *string `form:"msg,omitempty" json:"msg,omitempty" xml:"msg,omitempty"`
}

// NewUploadResponseBody builds the HTTP response body from the result of the
// "upload" endpoint of the "servers" service.
func NewUploadResponseBody(res *servers.Response) *UploadResponseBody {
	body := &UploadResponseBody{
		OK:    res.OK,
		Error: res.Error,
		Image: res.Image,
	}
	return body
}

// NewFetchResponseBody builds the HTTP response body from the result of the
// "fetch" endpoint of the "servers" service.
func NewFetchResponseBody(res *servers.Response) *FetchResponseBody {
	body := &FetchResponseBody{
		OK:    res.OK,
		Error: res.Error,
		Image: res.Image,
	}
	return body
}

// NewGetHealthResponseBody builds the HTTP response body from the result of
// the "get health" endpoint of the "servers" service.
func NewGetHealthResponseBody(res *servers.Health) *GetHealthResponseBody {
	body := &GetHealthResponseBody{
		Msg: res.Msg,
	}
	return body
}

// NewUploadReqUpload builds a servers service upload endpoint payload.
func NewUploadReqUpload(body *UploadRequestBody) *servers.ReqUpload {
	v := &servers.ReqUpload{
		UUID:  *body.UUID,
		Image: body.Image,
	}

	return v
}

// NewFetchReqGet builds a servers service fetch endpoint payload.
func NewFetchReqGet(body *FetchRequestBody) *servers.ReqGet {
	v := &servers.ReqGet{
		UUID: *body.UUID,
	}

	return v
}

// ValidateUploadRequestBody runs the validations defined on UploadRequestBody
func ValidateUploadRequestBody(body *UploadRequestBody) (err error) {
	if body.Image == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("image", "body"))
	}
	if body.UUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("uuid", "body"))
	}
	if body.UUID != nil {
		if utf8.RuneCountInString(*body.UUID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.uuid", *body.UUID, utf8.RuneCountInString(*body.UUID), 1, true))
		}
	}
	return
}

// ValidateFetchRequestBody runs the validations defined on FetchRequestBody
func ValidateFetchRequestBody(body *FetchRequestBody) (err error) {
	if body.UUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("uuid", "body"))
	}
	if body.UUID != nil {
		if utf8.RuneCountInString(*body.UUID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.uuid", *body.UUID, utf8.RuneCountInString(*body.UUID), 1, true))
		}
	}
	return
}
